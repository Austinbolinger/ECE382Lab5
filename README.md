ECE382Lab8
==========
Austin Bolinger

Dr. York

ECE 382

05 Nov 14


Description: Lab 5 is IR signals. Taking lab 3's pong game and making it react to the buttons pressed on a remote control.


##Prelab

**Setup**
This is what the set up looks like in picture form.

![set up]( https://github.com/Austinbolinger/ECE382Lab8/blob/master/setUp.JPG?raw=true "Set Up" )

O is for Output pin. G is for Ground pin. Vcc is for the power pin. And, the Output pin was actually attached to the Xin pin on the MSP430 not the port 1.3.

**Firmware**

Project built around [test5.c](http://ecse.bd.psu.edu/cmpen352/lab/lab5/test5.c)

1. How long will it take the timer to roll over?
  65535/8000000= 8.192ms
2. How long does each timer count last?
  It counts up to 0xFFFF
3. The while(1) loop in main reads in the ir pules in the for loop. Annotate the picture below to describe the which lines of the for loop the program is executed at which part of the pulse. You should show a total of 6 lines of code (lines 32-34 and lines 36-38).
  Lines 32-34, write to timer 0 which is the count for the bottom line of the IR wave. Lines 36-38, write to timer 1 which is the count length for the top line, high signal, for the IR wave.

![IR Wave]( https://github.com/Austinbolinger/ECE382Lab8/blob/master/irWave.gif?raw=true "IR Wave" )


**IR data packets**

This is the print outs from the Logic Anlyizer. They helped me realize the value of the time 0 and time 1 variables. After analyzing the time 0 and time 1, I soon realized that I only needed to look at time 1 for the 1 counts. I made an Excel sheet to easily record the data for each button press and do my math calculations quickly.

![outputs]( https://github.com/Austinbolinger/ECE382Lab8/blob/master/Lab5LogicAnalyzer1.jpg?raw=true "Outputs" )

If you look at the picture below, you can see that I mapped out the time0 before realizing how unimportant it was to me. However, it did help me to realize how time 1 could help me.

![timing]( https://github.com/Austinbolinger/ECE382Lab8/blob/master/Lab5LogicAnalyzer2.jpg?raw=true "Timing" )

1. List the lengths of the pulses generated by the remote control in absolute time using the O'scope (3 significant figures) and in timer A counts.

| Pulse | Duration (ms) | timer A counts |
| --- | --- | --- |
| Start logic 0 half-pulse | 1.11 |  89450 |
| Start logic 1 half-pulse | 0.553  | 4420 |
| Data 1 logic 0 half-pulse | 0.0770 | 616  |
| Data 1 logic 1 half-pulse | 0.206 | 1650  |
| Data 0 logic 0 half-pulse | 0.0770 | 616 |
| Data 0 logic 1 half-pulse | 0.0678 | 542 |
| Stop logic 0 half-pulse | 0.0771 | 620 |
| Stop logic 1 half-pulse | 5.369 | 42952 |

2. Collect 8 samples of timer A counts for each of the following pulse types. Compute the average and standard deviation of each pulse type. I would suggest just grabbing it from the CCS variables tab.

| Data | Logic half-pulse | Average Count | Avg. Time(ms) | St. Dev. Count | St. Dev. Time(ms) |
| --- | --- | --- | --- | --- | --- |
| 1 | 0 | 507.6 | 0.00635 | 25.3 | 0.00316 |
| 1 | 1 | 1621.9 | 0.203 | 28.99 | 0.00362 |
| 0 | 0 | 617 | 0.0771 | 3.13 | 0.000392 |
| 0 | 1 | 617 | 0.0771 | 3.13 | 0.000392 |

3. Tabulate this information in Excel, label the rows and columns of your table so that I will know what the information in each cell means.

| Button | code (not including start and stop bits) | Hex |
| --- | --- | --- |
| 0 | 0	1	1	0	0	0	0	1	1	0	1	0	0	0	0	0	1	0	0	1	0	0	0	0	0	1	1	0	1	1	1	1	 | 61A0906F |
| 1 | 0	1	1	0	0	0	0	1	1	0	1	0	0	0	0	0	0	0	0	0	0	0	0	0	1	1	1	1	1	1	1	1	 | 61A000FF |
| 2 | 0	1	1	0	0	0	0	1	1	0	1	0	0	0	0	0	1	0	0	0	0	0	0	0	0	1	1	1	1	1	1	1	 | 61A0807F |
| 3 | 0	1	1	0	0	0	0	1	1	0	1	0	0	0	0	0	0	1	0	0	0	0	0	0	1	0	1	1	1	1	1	1	 | 61A040BF |
| Power | 0	1	1	0	0	0	0	1	1	0	1	0	0	0	0	0	1	1	1	1	0	0	0	0	0	0	0	0	1	1	1	1	 | 61A0F00F |
| VOL + | 0	1	1	0	0	0	0	1	1	0	1	0	0	0	0	0	0	0	1	1	0	0	0	0	1	1	0	0	1	1	1	1	 | 61A030CF |
| VOL - | 0	1	1	0	0	0	0	1	1	0	1	0	0	0	0	0	1	0	1	1	0	0	0	0	0	1	0	0	1	1	1	1	 | 61A0B04F |
| CH + | 0	1	1	0	0	0	0	1	1	0	1	0	0	0	0	0	0	1	0	1	0	0	0	0	1	0	1	0	1	1	1	1	 | 61A050AF |
| CH - | 0	1	1	0	0	0	0	1	1	0	1	0	0	0	0	0	1	1	0	1	0	0	0	0	0	0	1	0	1	1	1	1	  | 61A0D02F |

##Required Functionality Code
Required functionality has the remote turn lights on and off on the MSP430.

####Debugging
The first step was to take the array given in the code and storing the time duration of each "1" count like done in the prelab. That time was split up according to zeros and ones. If the length of the IR wave was close to a zero time like found in the prelab, a zero was stored, and the same procedure was used for storing ones. A neat feature I used was starting my index counting at the start bit and stopping the array storage after 32 bits. I knew each code from the remote would be 32 bits long. So I compared the array to the known codes for each button pressed. The next step was just adding in code to turn on lights for when certain buttons were pressed. I demonstrated that the power toggles both lights, Vol+ turns red on, Vol- red off, Ch+ green on, and Ch- green off.

The biggest problem I had in this portion was shifting. I could not get my code from the array to another variable without C2C Wooden's help on the correct syntax for shifting. I was forgetting the "=" sign.

##A Functionality
A functionality code is taking code from lab 4 like the etch-a-sketch and controlling the functions with the remote.

####Debugging
This code stumped me for a long time. First of all it broke my Code Composer Studio. Then, I had to restart the coding several times before it finally would compile. That is why you will find the A functionality code in the OneLastAttempt folder. This code was the same as Required functionality but with code from lab 4 tossed in to it. I added the nokia file for drawing boxes on the LCD. I placed the box moving equations in the buttons pressed code. 1, 2, 3, & 0 acted as left, up, right, and down. The next step was to figure out when to initiate the draw box function and initiate the IR sensor functions. I spent many hours rearranging this. I finally just commented out all of the code that involved drawing the box because when that was active, the file broke when compiled. I started uncommenting line by line to see where the code was breaking. I found that when I got to the end the code worked and the remote was able to control the draw box functions as demonstrated. 


##Documentation: Dr. Coulston explained to me why only taking from timer 0 was bad. Now I understand why the data from timer 1 was most important for determining what the count times were.

C2C Wooden helped me figure out how to shift in my array correctly to another variable. He also figured out a hack to ignore an error that kept occuring where the shifting always threw in an extra 0. 
